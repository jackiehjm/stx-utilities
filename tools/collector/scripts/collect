#! /bin/bash
########################################################################
#
# Copyright (c) 2014-2021 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#
########################################################################
#
# Description: This script creates a tarball of logs and runtime
#              configuration information for any of the following
#
#              - current host     ... collect
#              - specified host   ... collect hostname
#              - group of hosts   ... collect --list ...
#              - all hosts        ... collect --all
#
# Behavior   : See print_help below.
#
# Inclusions : What is collected.
#
#    - /var/log
#    - /var/run (exclusions listed in /etc/collect/exclude.list)
#    - area specific configuration and data -> ./var/extra
#    - all databases in plain text ; except for ceilometer and keystone
#
# Additional collected info is expressed by the following runtime output.
# Generally, individual commands that display output have that output
# redirected to the appropriate info file in /scratch/var/extra
#
# sysadmin@controller-0:/scratch# sudo collect
# nodetype : controller
# Collector: /scratch
# Extra Dir: /scratch/var/extra
# Database : /scratch/database
# Tarball  : /scratch/controller-0.20140318.232925.tgz
# ------------------------------------------------------------------------
# controller-0: Process Info ......: /scratch/var/extra/process.info
# controller-0: Host Info .........: /scratch/var/extra/host.info
# controller-0: Memory Info .......: /scratch/var/extra/memory.info
# controller-0: Filesystem Info ...: /scratch/var/extra/filesystem.info
# controller-0: Bash History ......: /scratch/var/extra/history.info
# controller-0: Interrupt Info ....: /scratch/var/extra/interrupt.info
# controller-0: HA Info ...........: /scratch/var/extra/crm.info
# controller-0: CIB Admin Info ....: /scratch/var/extra/crm.xml
# controller-0: Mtce Info .........: /scratch/var/extra/mtce.info
# controller-0: Networking Info ...: /scratch/var/extra/networking.info
# controller-0: RabbitMQ Info .....: /scratch/var/extra/rabbitmq.info
# controller-0: Database Info .....: /scratch/var/extra/database.info
# controller-0: Dumping Database ..: /scratch/database/postgres.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/glance.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/nova.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/cinder.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/heat.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/neutron.db.sql.txt
# controller-0: Dumping Database ..: /scratch/database/sysinv.db.sql.txt
# controller-0: Creating Tarball ..: /scratch/controller-0.20140318.232925.tgz
#
# Tarball: /scratch/<hostname>.<date>.tgz
#
# The script first collects the process, host, memory,
# filesystem, interrupt and HA information.
# It then proceeds to calls run-parts against the
# /etc/collect.d direcory which contains service level
# collectors. Additional collected can be added to that
# collect.d directory and will be called automatically.
#
# Warning: Script currently must be run as root.
# The collector scripts consider nodetype when deciding
# which commands to execute where.
#
##################################################################


TOOL_NAME=collect
TOOL_VER=2
TOOL_REV=1

# only supported username
UN="sysadmin"

# pull in common utils and environment
source /usr/local/sbin/collect_utils

# collect must be run as sysadmin
if [ ${UID} -eq 0 ]; then
  elog "Cannot run collect as 'root' user"
  exit 1
fi

source_openrc_if_needed

function clean_up()
{
    # kill all processes whose parent is this process
    pkill -P $$
    $(reset)
    echo " clean up called"
}

function control_c()
{
    echo ""
    echo -n "... received exit signal ..."
    clean_up
    exit 0
}

# Handle exit signals
trap control_c SIGINT
trap control_c SIGTERM

# static expect log level control ;
# 0 = hide expect output
# 1 = show expect outout
USER_LOG_MODE=0

# limit scp bandwidth to 1MB/s
# increase limit of scp bandwidth from 1MB/s to 10MB/s
SCP_CMD="scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o PreferredAuthentications=password -o PubkeyAuthentication=no -l $((10*8*1000))"
SCP_TIMEOUT="600"
SSH_CMD="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o PreferredAuthentications=password -o PubkeyAuthentication=no"
NOWDATE=$(date +"%Y%m%d.%H%M%S")
COLLECT_BASE_DIR="/scratch"
collect_host="/usr/local/sbin/collect_host"
CURR_DIR=$(pwd)


# common permission error strings
pw_error="orry, try again"
ac_error="ermission denied"

function print_help()
{
    echo ""
    echo "Titanium Cloud Log Collection Tool, version ${TOOL_VER}.${TOOL_REV}"
    echo ""
    echo "Usage: ${TOOL_NAME} [COMMANDS ...] {options}"
    echo ""
    echo "Titanium Cloud 'collect' is used by the customer support organization"
    echo " to collect logs and data for off system analysis."
    echo ""
    echo "Running collect will collect logs to /scratch/<prefix_date_time.tar>"
    echo "on the host collect is run from. Use host names to specify which hosts to collect from."
    echo ""
    echo "Host data collection scope can be the current host, any single specified hostname,"
    echo "a --list of hostnames or --all hosts in the system using a single command."
    echo ""
    echo "Optionally specify --parallel or -p to collect from hosts in parallel"
    echo ""
    echo "Optionally specify --start-date and/or --end-date options to limit"
    echo "  the date range and therefore size of the collect."
    echo ""
    echo "Optionally specify a --name prefix of the collected tar file."
    echo ""
    echo "With the command set specified, simply run collect as sysadmin and when"
    echo "prompted provide the sysadmin sudo password and let collect handle the rest."
    echo ""
    echo "Scope Options:"
    echo ""
    echo " collect                                        ... collect logs for current host"
    echo " collect host1                                  ... collect logs for single named host"
    echo " collect host1 host2 host3                      ... collect logs for stacked host list"
    echo " collect [--list | -l] host1 host2 host3        ... collect logs for list of named hosts"
    echo " collect [--all  | -a]                          ... collect logs for all hosts"
    echo " collect -a -p                                  ... collect logs for all hosts in parallel"
    echo ""
    echo "Dated Collect:"
    echo ""
    echo "collect [--start-date | -s] YYYYMMDD            ... collection of logs on and  after this date"
    echo "collect [--end-date   | -e] YYYYMMDD            ... collection of logs on and before this date"
    echo ""
    echo "Tarball Prefix:"
    echo ""
    echo "collect [--name | -n] {scope and date options}  ... specify the name prefix of the collect tarball"
    echo ""
    echo "Detailed Display:"
    echo ""
    echo "collect [--verbose | -v]                        ... print details during collect"
    echo ""
    echo "collect [--inventory | -i]                      ... collect inventory by system cli command"
    echo ""
    echo "Avoid password and security masking:"
    echo ""
    echo "collect [--skip-mask]                           ... skip masking of collect data"
    echo ""
    echo "Examples:"
    echo ""
    echo "collect                                                      ... all logs for current host"
    echo "collect --all                                                ... all logs from all hosts in the system"
    echo "collect --all --start-date 20150101                          ... logs dated on and after Jan 1 2015 from all hosts"
    echo "collect --all --start-date 20151101 --end-date 20160201      ... logs dated between Nov 1, 2015 and Feb 1 2016 from all hosts"
    echo "collect --start-date 20151101 --end-date 20160201            ... only logs dated between Nov 1, 2015 and Feb 1 2016 for current host"
    echo "collect --list controller-0 worker-0 storage-0              ... all logs from specified host list"
    echo "collect --list controller-0 worker-1 --end-date 20160201    ... only logs before Nov 1, 2015 for host list"
    echo "collect --list controller-1 storage-0 --start-date 20160101  ... only logs after Jan 1 2016 for controller-1 and storage-0"
    echo ""
    exit 0
}

# command line arguement variables ; defaulted
DEBUG=false
CLEAN=false
ASYNC=false
VERBOSE=false
SKIP_MASK=false
INVENTORY=false

# date variables
STARTDATE="any"
STARTTIME="any"
ENDDATE="any"
ENDTIME="any"
GETSTARTDATE=false
GETENDDATE=false

# host selection variables
LISTING=false
ALLHOSTS=false
HOSTS=1
HOSTLIST=(${HOSTNAME})

# overall collect timeout
TIMEOUT=1000

COLLECT_TARNAME=""

# clear multi option modes
function clear_variable_args()
{
    LISTING=false
    GETSTARTDATE=false
    GETENDDATE=false
}

space_precheck ${HOSTNAME} ${COLLECT_BASE_DIR}

############################################################################
#
# Name       : report_error
#
# Purpose    : Report error to console and logfile
#
# Assumptions: Handles specific cases of invalid password and permission errors
#              by exiting so as to avoid repeated errors during multi-host
#              collection.
#
# $1 - status string
# $2 - status code number
#
function report_error()
{
    local string=${1}
    local code=${2}

    if [ ${code} -eq ${FAIL_PASSWORD} ] ; then
        elog "Invalid password"
        exit ${code}

    elif [ ${code} -eq ${FAIL_PERMISSION} ] ; then
        elog "Permission error ; exiting (${string})"
        exit ${code}

    elif [ ${code} -eq ${FAIL_UNREACHABLE} ] ; then
        elog "${string} (reason:${code}:host unreachable)"

    elif [ ${code} -eq ${FAIL_PERMISSION_SKIP} ] ; then
        elog "${string} (reason:${code}:permission error)"

    elif [ ${code} -eq ${FAIL_OUT_OF_SPACE} ] ; then
        elog "${string} (reason:${code}:${FAIL_NOT_ENOUGH_SPACE_STR}) ; need to increase available space ${COLLECT_BASE_DIR}"

    elif [ ${code} -eq ${FAIL_INSUFFICIENT_SPACE} ] ; then
        elog "${string} (reason:${code}:${FAIL_NOT_ENOUGH_SPACE_STR}) ; ${COLLECT_BASE_DIR} usage must be below ${MIN_PERCENT_SPACE_REQUIRED}%"

    elif [ ${code} -ge ${FAIL_TIMEOUT} -a ${code} -le ${FAIL_TIMEOUT9} ] ; then
        elog "${string} (reason:${code}:operation timeout)"

    elif [ ${code} -ge ${FAIL_HOSTNAME} ] ; then
        wlog "${string} (reason:${code})"

    else
        elog "${string} (reason:${code})"
    fi
}

#
# checks to see if the specified hostname is known
# to inventory as a valid provisioned host

# $1 - this_hostname

function is_valid_host()
{
    local this_hostname=${1}

    if [ "${this_hostname}" == "None" ] ; then
        return ${FAIL_HOSTNAME}
    elif [ "${this_hostname}" == "${HOSTNAME}" ] ; then
        return ${PASS}
    elif [ "${ACTIVE}" = true ] ; then
        system host-show "${this_hostname}" 2>/dev/null 1>/dev/null
        if [ ${?} -ne 0 ] ; then
            return ${FAIL_HOSTNAME}
        fi
    else
        report_error "can only run collect for remote hosts on active controller" ${FAIL_INACTIVE}
        exit ${FAIL_INACTIVE}
    fi
    return ${PASS}
}


# Parse the command line
while [[ ${#} -gt 0 ]] ; do

    key="${1}"

    case $key in

        -h|--help)
        print_help
        exit 0
        ;;

        -n|--name)
        COLLECT_TARNAME=${2}_${NOWDATE}
        clear_variable_args
        shift
        ;;

        -v|--verbose)
        USER_LOG_MODE=1
        VERBOSE=true
        ;;

        -c|--clean)
        CLEAN=true
        ;;

        -i|--inventory)
        INVENTORY=true
        ;;

        -l|--list)
        if [[ ${#} -lt  2 ]] ; then
            report_error "empty host list" ${FAIL_HOSTNAME}
            exit ${FAIL}
        fi
        is_valid_host "${2}"
        if [ ${?} -ne 0 ] ; then
            report_error "empty host list or invalid first hostname" ${FAIL_HOSTNAME}
            exit ${FAIL_HOSTNAME}
        fi

        HOSTLIST=(${2})
        HOSTS=1
        if [ "${ACTIVE}" = false ] ; then
            report_error "can only run collect for remote hosts on active controller" ${FAIL_INACTIVE}
            exit ${FAIL_INACTIVE}
        fi
        LISTING=true
        GETSTARTDATE=false
        GETENDDATE=false
        shift
        ;;

        -a|--all|all)
        if [ "${ACTIVE}" = false ] ; then
            report_error "can only run collect for remote hosts on active controller" ${FAIL_INACTIVE}
            exit ${FAIL_INACTIVE}
        fi
        ALLHOSTS=true
        HOSTLIST=(${HOSTNAME})
        HOSTS=1
        clear_variable_args
        ;;

        -s|--start-date)
        STARTDATE="${2}"
        LISTING=false
        GETSTARTDATE=true
        GETENDDATE=false
        shift
        ;;

        -e|--end-date)
        ENDDATE="${2}"
        LISTING=false
        GETSTARTDATE=false
        GETENDDATE=true
        shift
        ;;

        -d|--debug)
        DEBUG=true
        clear_variable_args
        ;;

        --skip-mask)
        SKIP_MASK=true
        shift
        ;;

        -p|--parallel)
        ASYNC=true
        SECONDS=0
        let UNTIL=${SECONDS}+${TIMEOUT}
        dlog "collect timeout is ${TIMEOUT}"
        ;;

        *)
        if [ "${LISTING}" = true ] ; then
            is_valid_host ${key}
            if [ ${?} -eq 0 ] ; then
                HOSTS=$((HOSTS+1))
                HOSTLIST=( "${HOSTLIST[@]}" ${key} )
            else
                # make the invalid hostname a warning only.
                # if we got here then at least the first hostname was valid
                report_error "cannot collect data from unknown host '${key}'" ${WARN_HOSTNAME}
            fi
        elif [ "${GETSTARTDATE}" = true ] ; then
            dlog "accepting but ignoring legacy starttime specification"
        elif [ "${GETENDDATE}" = true ] ; then
            dlog "accepting but ignoring legacy endtime specification"
        else
            is_valid_host ${key}
            rc=${?}
            if [ ${rc} -eq 0 ] ; then
                HOSTLIST=${key}
                HOSTS=1
                LISTING=true
            else
                report_error "cannot collect data from unknown host '${key}'" ${rc}
                exit ${rc}
            fi
        fi
        GETSTARTDATE=false
        GETENDDATE=false
        ;;
    esac
    shift # past argument or value
done

#
# request root password and use it for
# all the expect driven requests below
#
read -s -p "[sudo] password for ${USER}:" pw
echo ""

# Although bash 'read' will handle sanitizing the password
# input for the purposes of storing it in ${pw}, expect
# will need certain special characters to be backslash
# delimited
pw=${pw/\\/\\\\} # replace '\' with '\\'
pw=${pw/\]/\\\]} # replace ']' with '\]'
pw=${pw/\[/\\\[} # replace '[' with '\['
pw=${pw/$/\\$}   # replace '$' with '\$'
pw=${pw/\"/\\\"} # replace '"' with '\"'

#
# if the user specified the '--all' option then override
# the current list and add them all from inventory.
#
if [ "${ALLHOSTS}" = true ] ; then

    for foreign_host in $(system host-list | grep '[0-9]' | cut -d '|' -f 3 | tr -d ' ' | grep -v ${HOSTNAME}); do
        if [ "${foreign_host}" != "None" ] ; then
            HOSTS=$((HOSTS+1))
            HOSTLIST=( "${HOSTLIST[@]}" ${foreign_host})
        fi
    done

elif [ ${HOSTS} == 0 ] ; then

    HOSTLIST=${HOSTNAME}
    COLLECT_TARNAME="${HOSTNAME}_${NOWDATE}"

fi

# debug logs
dlog "HOSTLIST = ${HOSTLIST[@]}"
dlog "HOSTS    = ${HOSTS}"
dlog "ALLHOSTS = ${ALLHOSTS}"
dlog "STARTDATE= ${STARTDATE}"
dlog "ENDDATE  = ${ENDDATE}"
dlog "SECONDS  = ${SECONDS}"
for hosts in "${HOSTLIST[@]}" ; do
    dlog "Host:${hosts}"
done

if [ ${HOSTS} -eq 0 ] ; then
     elog "no hosts specified"
     exit ${FAIL}
fi
if [ "${CLEAN}" == false ] ; then
    ilog "collecting data from ${HOSTS} host(s): ${HOSTLIST[@]}"
else
    ilog "cleaning scratch space on ${HOSTLIST[@]}"
fi

#
# removes contents of the local /scratch directory
#
# $1 - host
# $2 - specified directory (always $COLLECT_BASE_DIR)
#
function clean_scratch_dir_local ()
{
    local this_hostname=${1}
    local directory=${2}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout 60
    expect -re $
    send -- "sudo rm -rf ${directory}/*_????????.??????* ; cat ${cmd_done_file}\n"
    expect {
        "assword:"        { send "${pw}\r" ; exp_continue }
        "${cmd_done_sig}" { exit ${PASS} }
        "annot remove"    { exit ${FAIL_CLEANUP}    }
        "${pw_error}"     { exit ${FAIL_PASSWORD}   }
        "${ac_error}"     { exit ${FAIL_PERMISSION} }
        timeout           { exit ${FAIL_TIMEOUT}    }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "clean_scratch_dir_local ${this_hostname} failed" ${rc}
   fi
   return ${rc}
}

#
# cleans the contents of the specified hosts's scratch dir
#
# $1 - this hostname
# $2 - specified directory (always $COLLECT_BASE_DIR)
#
function clean_scratch_dir_remote()
{
    local this_hostname=${1}
    local directory=${2}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    expect -re $
    set timeout 60
    send "${SSH_CMD} ${UN}@${this_hostname}\n"
    expect {
        "assword:" {
            send "${pw}\r"
            expect {
                "${this_hostname}" {
                    set timeout 30
                    expect -re $
                    send "sudo rm -rf ${directory}/*_????????.??????* ; cat ${cmd_done_file}\n"
                    expect {
                        "assword:" { send -- "${pw}\r" ; exp_continue }
                        "${cmd_done_sig}" { exit ${PASS} }
                        "${cmd_done_file}: No such file or directory" { exit ${PASS} }
                        "annot remove"    { exit ${FAIL_CLEANUP}   }
                        "${pw_error}"     { exit ${FAIL_PASSWORD}  }
                        "${ac_error}"     { exit ${FAIL_PERMISSION}}
                        timeout           { exit ${FAIL_TIMEOUT3}  }
                    }
                }
                timeout { exit ${FAIL_TIMEOUT1} }
            }
        }
        "(yes/no)?" {
            send "yes\r"
            exp_continue
        }
        "No route to host" {
            exit ${FAIL_UNREACHABLE}
        }
        "Could not resolve hostname" {
            exit ${FAIL_UNREACHABLE}
        }
        timeout { exit ${FAIL_TIMEOUT} }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "clean_scratch_dir_remote ${this_hostname} failed" ${rc}
   fi
   return ${rc}
}

#
# deletes a remote directory or file
#
# $1 - this hostname
# $2 - dir or file with full path
#
function delete_remote_dir_or_file()
{
    local this_hostname=${1}
    local dir_or_file=${2}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    expect -re $
    set timeout 60
    send "${SSH_CMD} ${UN}@${this_hostname}\n"
    expect {
        "assword:" {
            send "${pw}\r"
            expect {
                "${this_hostname}:" {
                    set timeout 10
                    expect -re $
                    send "sudo rm -rf ${dir_or_file} ; cat ${cmd_done_file}\n"
                    expect {
                        "assword:" { send -- "${pw}\r" ; exp_continue }
                        "${cmd_done_sig}" { exit ${PASS} }
                        "${cmd_done_file}: No such file or directory" { exit ${PASS} }
                        "annot remove"    { exit ${FAIL_CLEANUP}   }
                        "${pw_error}"     { exit ${FAIL_PASSWORD}  }
                        "${ac_error}"     { exit ${FAIL_PERMISSION}}
                        timeout           { exit ${FAIL_TIMEOUT3}  }
                    }
                }
                timeout { exit ${FAIL_TIMEOUT1} }
            }
        }
        "(yes/no)?" {
            send "yes\r"
            exp_continue
        }
        "No route to host" {
            exit ${FAIL_UNREACHABLE}
        }
        "Could not resolve hostname" {
            exit ${FAIL_UNREACHABLE}
        }
        timeout { exit ${FAIL_TIMEOUT} }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "delete_remote_dir_or_file ${this_hostname} failed" ${rc}
   fi
   return ${rc}
}

HOST_COLLECT_ERROR_LOG="/tmp/host_collect_error.log"
#
# Fetch a file from a remote host using the global pw
# $1 - this hostname
# $2 - remote source path/filename
# $3 - local path destination
#
function get_file_from_host()
{
    local this_hostname=${1}
    local remote_src=${2}
    local local_dest=${3}

    remove_file_local ${HOST_COLLECT_ERROR_LOG}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout ${SCP_TIMEOUT}
    expect -re $
    send "${SCP_CMD} ${UN}@${this_hostname}:${remote_src} ${local_dest} 2>>${HOST_COLLECT_ERROR_LOG}\n"
    expect {
        "assword:" {
            send "${pw}\r"
            expect {
                "100%"        { exit ${PASS} }
                "${pw_error}" { exit ${FAIL_PASSWORD}  }
                "${ac_error}" { exit ${FAIL_PERMISSION}}
                timeout       { exit ${FAIL_TIMEOUT1}  }
            }
        }
        "No route to host" {
            exit ${FAIL_UNREACHABLE}
        }
        "Could not resolve hostname" {
            exit ${FAIL_UNREACHABLE}
        }
        timeout { exit ${FAIL_TIMEOUT} }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "failed to get_file_from ${this_hostname}" ${rc}
   else
       # Look for "No space left on device" error
       grep -q "${FAIL_OUT_OF_SPACE_STR}" ${HOST_COLLECT_ERROR_LOG}
       if [ "$?" == "0" ] ; then
           rc=${FAIL_OUT_OF_SPACE}
       fi
   fi

   remove_file_local ${HOST_COLLECT_ERROR_LOG}

   return ${rc}
}

#
# Create the local dated collect dir where all
#  the tarballs for this collect will get put.
#
# Permissions are set to make it easy to copy
#  tarballs from remote host into
#
# $1 - the fill dir
#
function create_collect_dir_local()
{
    local dir=${1}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout 10
    expect -re $
    send "sudo mkdir -m 775 -p ${dir} ; cat ${cmd_done_file}\n"
    expect {
        "assword:" {
            send "${pw}\r"
            expect {
                "${cmd_done_sig}" { exit ${PASS}           }
                "${pw_error}"     { exit ${FAIL_PASSWORD}  }
                "${ac_error}"     { exit ${FAIL_PERMISSION}}
                timeout           { exit ${FAIL_TIMEOUT1}  }
            }
        }
        "${cmd_done_sig}" { exit ${PASS} }
        "${ac_error}"     { exit ${FAIL_PERMISSION}}
        timeout           { exit ${FAIL_TIMEOUT} }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "failed to create_collect_dir_local for ${dir}" ${rc}
       exit ${rc}
   fi
   return ${rc}
}

#
# Delete the specified file using sudo
#
# $1 - the file to be delete with full path specified
#
function remove_file_local()
{
    local local_file=${1}
    local rc=${PASS}

    if [ -e ${local_file} ] ; then

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout 10
    expect -re $
    send -- "sudo rm -f ${local_file} ; cat ${cmd_done_file}\n"
    expect {
        "assword:"        { send -- "${pw}\r" ; exp_continue }
        "${cmd_done_sig}" { exit ${PASS} }
        "annot remove"    { exit ${FAIL_CLEANUP}    }
        "${pw_error}"     { exit ${FAIL_PASSWORD}   }
        "${ac_error}"     { exit ${FAIL_PERMISSION} }
        timeout           { exit ${FAIL_TIMEOUT}    }
    }
EOF
       local rc=${?}
       if [ ${rc} -ne ${PASS} ] ; then
           report_error "failed to remove_file_local ${local_file}" ${rc}
       fi
   fi
   return ${rc}
}

#
# Delete the specified file using sudo
#
# $1 - the directory to be removed with full path specified
#
function remove_dir_local()
{
    local dir=${1}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout 10
    expect -re $
    send -- "sudo rm -rf ${dir} ; cat ${cmd_done_file}\n"
    expect {
        "assword:"        { send -- "${pw}\r" ; exp_continue }
        "${cmd_done_sig}" { exit ${PASS} }
        "annot remove"    { exit ${FAIL_CLEANUP}    }
        "${pw_error}"     { exit ${FAIL_PASSWORD}   }
        "${ac_error}"     { exit ${FAIL_PERMISSION} }
        timeout           { exit ${FAIL_TIMEOUT}    }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "failed to remove_dir_local ${dir}" ${rc}
   fi
   return ${rc}
}

#
# Move a file and change permissions using sudo
#
# $1 - src  path/file
# $2 - dest path/file
#
function move_file_local()
{
    local src=${1}
    local dst=${2}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    set timeout 10
    expect -re $
    send -- "sudo mv ${src} ${dst} ; cat ${cmd_done_file}\n"
    expect {
        "assword:"        { send -- "${pw}\r" ; exp_continue }
        "${cmd_done_sig}" { exit ${PASS} }
        "annot remove"    { exit ${FAIL_CLEANUP}    }
        "${pw_error}"     { exit ${FAIL_PASSWORD}   }
        "${ac_error}"     { exit ${FAIL_PERMISSION} }
        timeout           { exit ${FAIL_TIMEOUT}    }
    }
EOF
   local rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       report_error "failed to move_file_local ${src} to ${dst}" ${rc}
   fi
   return ${rc}
}

# Append the echoed collect done with collect duration and file size
# ... done (HH:MM:SS xxM)
function echo_stats()
{
    local secs=${1}
    local label="${2}"
    local file="${3}"
    MSG=""
    if [ $label != "stats-only" ] ; then
       if [ "${ASYNC}" = true ] ; then

            MSG="collected "
            len=${#label}
            for ((i=len;i<longest_hostname+16;i++))
            do
                MSG+=" "
            done

            MSG+="${label} ... done"
        fi
    fi

    MSG+=" ($(date -d@${secs} -u +%H:%M:%S)"
    if [ -e ${file} ] ; then
        size=$(du -h ${file} | cut -f 1 2>/dev/null)
        if [ $? -eq 0 ] ; then
            printf "%s %5s)\n" "${MSG}" "${size}"
            return
        fi
    fi
    printf "%s )\n" "${MSG}"
}

############################################################################
#
# Name       : collect_host_run
#
# Purpose    : Run collect host in selected mode
#
# Description: Run collect_host as a background task for each host if
#              parallel option is specified. Otherwise, run collect in
#              forground (legacy mode) for each host one after the other.
#
############################################################################

function collect_host_run()
{
    local host="${1}"
    local rc=${PASS}

    if [ "${ASYNC}" = false ] ; then
        MSG="collecting"
        # line up the host names
        len=${#host}
        for ((i=len;i<longest_hostname;i++))
        do
            MSG+=" "
        done
        MSG+=" ${TARNAME} ... "
        echo -n "$MSG"
        MSG=""
    fi

    # Save current user log level
    save=${USER_LOG_MODE}
    if [ "${VERBOSE}" = true ] ; then
        USER_LOG_MODE=1
    fi

    if [ "${host}" == "${HOSTNAME}" ] ;  then

/usr/bin/expect << EOF
        trap exit {SIGINT SIGTERM}
        log_user ${USER_LOG_MODE}
        spawn bash -i

        set timeout ${TIMEOUT}
        send "sudo SKIP_MASK=${SKIP_MASK} ${collect_host} ${TARNAME} ${STARTDATE_OPTION} ${STARTDATE} ${STARTTIME} ${ENDDATE_OPTION} ${ENDDATE} ${ENDTIME} ${VERBOSE} ${INVENTORY}\n"
        expect {
            "assword:" {
                send "${pw}\r"
                expect {
                    "${FAIL_INSUFFICIENT_SPACE_STR}" { exit ${FAIL_INSUFFICIENT_SPACE}}
                    "${FAIL_OUT_OF_SPACE_STR}" { exit ${FAIL_OUT_OF_SPACE}}
                    "${collect_done}"          { exit ${PASS}             }
                    "${pw_error}" { exit ${FAIL_PASSWORD}  }
                    "${ac_error}" { exit ${FAIL_PERMISSION}}
                    timeout       { exit ${FAIL_TIMEOUT}   }
                }
            }
            timeout { exit ${FAIL_TIMEOUT} }
        }
        exit { ${FAIL} }
EOF
        rc=${?}

    # otherwise the host is remote
    else

/usr/bin/expect << EOF
        trap exit {SIGINT SIGTERM}
        log_user ${USER_LOG_MODE}
        spawn bash -i
        set timeout 30
        expect -re $
        send "${SSH_CMD} ${UN}@${host}\n"
        expect {
            "assword:" {
                send "${pw}\r"
                expect {
                    "${host}:" {
                        set timeout 600
                        send "sudo SKIP_MASK=${SKIP_MASK} ${collect_host} ${TARNAME} ${STARTDATE_OPTION} ${STARTDATE} ${STARTTIME} ${ENDDATE_OPTION} ${ENDDATE} ${ENDTIME} ${VERBOSE} ${INVENTORY}\n"
                        expect {
                            "assword:" {
                                send "${pw}\r"
                                expect {
                                    "${FAIL_INSUFFICIENT_SPACE_STR}" {
                                       send "exit\r"
                                       exit ${FAIL_INSUFFICIENT_SPACE}
                                    }
                                    "${FAIL_OUT_OF_SPACE_STR}" {
                                       send "exit\r"
                                       exit ${FAIL_OUT_OF_SPACE}
                                    }
                                    "${collect_done}" {
                                        send "exit\r"
                                        exit ${PASS}
                                    }
                                    "${pw_error}"   { exit ${FAIL_PASSWORD} }
                                    "${ac_error}"   { exit ${FAIL_PERMISSION_SKIP}}
                                    timeout         { exit ${FAIL_TIMEOUT5} }
                                }
                            }
                            timeout { exit ${FAIL_TIMEOUT4} }
                        }
                    }
                    "${pw_error}" { exit ${FAIL_PASSWORD} }
                    "${ac_error}" { exit ${FAIL_PERMISSION_SKIP}}
                    timeout       { exit ${FAIL_TIMEOUT3} }
                }
            }
            "(yes/no)?" {
                send "yes\r"
                exp_continue
            }
            "No route to host" {
                exit ${FAIL_UNREACHABLE}
            }
            "Could not resolve hostname" {
                exit ${FAIL_UNREACHABLE}
            }
            "Host key verification failed" {
                send "rm -f /home/${UN}/.ssh/known_hosts\n"
                exit ${FAIL}
            }
            timeout { exit ${FAIL_TIMEOUT} }
        }
        exit { $FAIL }
EOF
        rc=${?}
    fi

    USER_LOG_MODE=${save}
    return ${rc}
}

############################################################################
#
# Name       : collect_host_complete_local
#
# Description: Perform collect host complete operations for a
#              local collect host.
#
#              1. Get the tarball
#              2. Handle errors
#                 - report
#                 - cleanup
#
############################################################################

function collect_host_complete_local()
{
    local tarname="${1}"
    local rc=${PASS}

    # create the dir again just to handle the case where we are
    # collecting on ourself and have removed the collect_dir
    # directory in collect_host above.
    create_collect_dir_local "${COLLECT_DIR}"

    # move the tarball into the collect dir
    # only applies to the local collect since the remote
    # collect scp's it directly into the collect dir.
    move_file_local "${COLLECT_BASE_DIR}/${tarname}.tgz" "${COLLECT_DIR}"
    rc=${?}
    if [ ${rc} -eq ${PASS} ] ; then
        logger -t ${COLLECT_TAG} "collect ${COLLECT_BASE_DIR}/${tarname}.tgz succeeded"
    else
        if [ ${rc} -eq ${FAIL_INSUFFICIENT_SPACE} ] ; then

            report_error "${FAIL_INSUFFICIENT_SPACE_STR}" ${rc}

            echo ""
            wlog "Increase available space in ${host}:${COLLECT_BASE_DIR} and retry operation."
            echo ""

            remove_dir_local ${COLLECT_DIR}

            exit ${FAIL_INSUFFICIENT_SPACE}

        elif [ ${rc} -eq ${FAIL_OUT_OF_SPACE} ] ; then

            report_error "${FAIL_OUT_OF_SPACE_STR}" ${rc}

            echo ""
            wlog "Increase available space in ${host}:${COLLECT_BASE_DIR} and retry operation."
            echo ""

            # Remove the corrupt file and exit
            remove_file_local ${COLLECT_ERROR_LOG}
            remove_file_local ${COLLECT_BASE_DIR}/${tarname}.tgz
            remove_dir_local ${COLLECT_BASE_DIR}/${tarname}
            remove_dir_local ${COLLECT_BASE_DIR}/${COLLECT_NAME}

            exit ${FAIL_OUT_OF_SPACE}

        else
            report_error "failed to collect from ${HOSTNAME}" ${rc}
        fi
    fi
    return ${rc}
}

############################################################################
#
# Name       : collect_host_complete_remote
#
# Description: Perform collect host complete operations for a
#              remote host collect.
#
#              1. Fetch the tarball
#              2. Remove tarball from remote host
#              2. Handle errors
#                 - report
#                 - cleanup
#
############################################################################

function collect_host_complete_remote ()
{
    local host="${1}"
    local tarname="${2}"

    get_file_from_host "${host}" "${COLLECT_BASE_DIR}/${tarname}.tgz" "${COLLECT_DIR}"
    local rc=${?}
    if [ ${rc} -eq ${PASS} ] ; then
        delete_remote_dir_or_file "${host}" "${COLLECT_BASE_DIR}/${tarname}.tgz"
        rc=$?
        if [ ${rc} -eq ${PASS} ] ; then
            logger -t ${COLLECT_TAG} "collect ${COLLECT_BASE_DIR}/${tarname}.tgz succeeded"
        else
            logger -t ${COLLECT_TAG} "collect ${COLLECT_BASE_DIR}/${tarname}.tgz succeeded but failed to cleanup"
            rc=${PASS}
        fi
    else
        report_error "failed to collect from ${host}" ${rc}
    fi
    return ${rc}
}

############################################################################
#
# Parallel Collect Support
#
# collect_host_run     - run collect_host as a background task
# collect_host_monitor - monitor for collect_host background task status
# collect_host_done    - mark collect_host done with status
# collect_host_stats   - print collect host stats
#
# collect_host_complete_local  - local collect complete operations
# collect_host_complete_remote - remote collect complete operations
#
# collect_host_ctrl_list_index_print - print collect host control list@index
#
# collect_host_ctrl_list is a structured host list used to track the state of
# collect_host run as a background task for each host.
#
# Structure members:
#
#  hostname - the name of the host being collected
#  stage    - the collect stage for this host ; RUN, MON, DONE
#  pid      - the pid of the background'ed collect host process
#  seconds  - the time in seconds of when the collect started
#  status   - the exit status of the remote collect 0..255
#  name     - the full path and name of the remote collected tarball
#
############################################################################
declare collect_host_ctrl_list=()

# The following index constants are used to access each field.
declare -r INDEX_HOST=0
declare -r INDEX_STAGE=1
declare -r INDEX_PID=2
declare -r INDEX_SECONDS=3
declare -r INDEX_STATUS=4
declare -r INDEX_TARBALL=5

# The stages each launched collect_host goes through
declare -r STAGE_RUN="run"
declare -r STAGE_MON="monitor"
declare -r STAGE_DONE="done"

declare -r INVALID_PID=-1

###########################################################################
#
# Name       : collect_host_monitor
#
# Purpose    : Transition host into tjhe monitor stage
#
############################################################################

function collect_host_monitor()
{
    local index=${1}

    if [ ${index} -lt ${HOSTS} ] ; then
        HOST=${collect_host_ctrl_list[${index}]}
        info=(${HOST//:/ })

        # Update collect host control structure for this host with
        #
        # collect_host_ctrl_list[index].stage = MONitor
        #
        collect_host_ctrl_list[${index}]="${info[${INDEX_HOST}]}:\
                                          ${STAGE_MON}:\
                                          ${info[${INDEX_PID}]}:\
                                          ${info[${INDEX_SECONDS}]}:\
                                          ${info[${INDEX_STATUS}]}:\
                                          ${info[${INDEX_TARBALL}]}"
        collect_host_ctrl_list_index_print ${index}
    else
        elog "collect_host_monitor called with invalid host index ${index} ; must be smaller than ${HOSTS}"
        exit ${FAIL_INTERNAL}
    fi
}

###########################################################################
#
# Name       : collect_host_done
#
# Purpose    : mart a host collect as done
#
############################################################################

function collect_host_done()
{
    local index=${1}
    local status=${2}

    if [ ${index} -lt ${HOSTS} ] ; then
        HOST=${collect_host_ctrl_list[${index}]}
        info=(${HOST//:/ })

        # update struct for this pid/process with
        #
        # collect_host_ctrl_list[index].stage = DONE
        # collect_host_ctrl_list[index].seconds = script run time
        # collect_host_ctrl_list[index].status = status
        HOST_START_TIME=${info[${INDEX_SECONDS}]}
        collect_host_ctrl_list[${index}]="${info[${INDEX_HOST}]}:\
                                          ${STAGE_DONE}:\
                                          ${INVALID_PID}:\
                                          $((SECONDS-HOST_START_TIME)):\
                                          ${status}:\
                                          ${info[${INDEX_TARBALL}]}"
        collect_host_ctrl_list_index_print ${index}
    else
        elog "collect_host_done called with invalid host index ${index} ; must be smaller than ${HOSTS}"
        exit ${FAIL_INTERNAL}
    fi
}

###########################################################################
#
# Name       : collect_host_stats
#
# Purpose    : call echo stats for specified collect_host_ctrl_list index
#
############################################################################

function collect_host_stats()
{
    local index=${1}

    HOST=${collect_host_ctrl_list[${index}]}
    info=(${HOST//:/ })
    echo_stats "${info[${INDEX_SECONDS}]}" \
               "${info[${INDEX_TARBALL}]}" \
               "${COLLECT_DIR}/${info[${INDEX_TARBALL}]}.tgz"
}

###########################################################################
#
# Name       : collect_host_ctrl_list_index_print
#
# Purpose    : debug
#
# Description: print the structure for a specified index
#
############################################################################

collect_host_ctrl_list_index_print()
{
    local index=${1}

    if [ "${DEBUG}" = true ] ; then
        HOST=${collect_host_ctrl_list[${index}]}
        info=(${HOST//:/ })
        printf "%s Debug: %-12s %7s [%6s] | Secs:%3s | %3s | %s\n" \
            "$(date)" \
            "${info[${INDEX_HOST}]}" \
            "${info[${INDEX_STAGE}]}" \
            "${info[${INDEX_PID}]}" \
            "${info[${INDEX_SECONDS}]}" \
            "${info[${INDEX_STATUS}]}" \
            "${info[${INDEX_TARBALL}]}"
    fi
}


# Handle clean command option
if [ "${CLEAN}" = true ] ; then
    for host in "${HOSTLIST[@]}" ; do
        if [ "${host}" != " " ] ; then

            if [ "${host}" == "None" ] ; then
                continue
            elif [ "${host}" == "" ] ; then
                continue
            fi

            echo -n "cleaning ${host}:${COLLECT_BASE_DIR} ... "
            if [ "${host}" == "${HOSTNAME}" ] ; then
                clean_scratch_dir_local ${host} ${COLLECT_BASE_DIR}
                if [ ${?} -eq ${PASS} ] ; then
                    echo "done"
                fi
            else
                clean_scratch_dir_remote ${host} ${COLLECT_BASE_DIR}
                if [ ${?} -eq ${PASS} ] ; then
                    echo "done"
                fi
            fi
            logger -t ${COLLECT_TAG} "user cleaned ${host}:${COLLECT_BASE_DIR} content"
        fi
    done
    exit 0
fi


if [ ! -z ${COLLECT_TARNAME} ] ; then

    # User specified tarname
    COLLECT_NAME=${COLLECT_TARNAME}
    COLLECT_DIR="${COLLECT_BASE_DIR}/${COLLECT_NAME}"
    TARBALL_NAME="${COLLECT_DIR}.tar"
	named="user-named"

elif [ "${ALLHOSTS}" = true ] ; then

    # All hosts bundle
    COLLECT_NAME="ALL_NODES_${NOWDATE}"
    COLLECT_DIR="${COLLECT_BASE_DIR}/${COLLECT_NAME}"
    TARBALL_NAME="${COLLECT_DIR}.tar"
	named="all-nodes"


elif [ ${HOSTS} -eq 1 ] ; then

    # Single host bundle
    COLLECT_NAME="${HOSTLIST[0]}_${NOWDATE}"
    COLLECT_DIR="${COLLECT_BASE_DIR}/${COLLECT_NAME}"
    TARBALL_NAME="${COLLECT_DIR}.tar"
	named="single-node"

else

    # Otherwise its a multi host bundle
    COLLECT_NAME="SELECT_NODES_${NOWDATE}"
    COLLECT_DIR="${COLLECT_BASE_DIR}/${COLLECT_NAME}"
    TARBALL_NAME="${COLLECT_DIR}.tar"
	named="selected-node"

fi

#
# Create the local collect directory where
#   the tarball(s) will temporarily stored
#
create_collect_dir_local "${COLLECT_DIR}"

declare COLLECT_START_TIME=${SECONDS}

declare -i longest_hostname=0
for host in "${HOSTLIST[@]}" ; do
    len=${#host}
    if [ $len -gt ${longest_hostname} ] ; then
        longest_hostname=$len
    fi
done

#
# Loop over all the targetted hosts and
# 1. run collect_host
#    - all hosts at once with the -p | --parallel option
#    - otherwise collect one after the other serially.
# 2. copy the tarball to $COLLECT_DIR
#

for host in "${HOSTLIST[@]}" ; do
   if [ "${host}" != " " ] ; then

        if [ "${host}" == "None" ] ; then
            continue
        elif [ "${host}" == "" ] ; then
            continue
        fi
        HOST_START_TIME=${SECONDS}
        TARNAME="${host}_${NOWDATE}"

        if [ "${ASYNC}" = false ] ; then

            collect_host_run "${host}" "${TARNAME}"
            rc=${?}
            if [ ${rc} -eq ${PASS} ] ; then

                if [ "${host}" == "${HOSTNAME}" ] ; then
                    collect_host_complete_local "${TARNAME}"
                else
                    collect_host_complete_remote "${host}" "${TARNAME}"
                fi
                rc=${?}
                if [ ${rc} -ne ${PASS} ] ; then
                    # handle copy error here
                    report_error "failed to collect from ${host}" ${rc}
                else
                    secs=$((SECONDS-HOST_START_TIME))
                    echo -n "done"
                    echo_stats $secs "${TARNAME}" "${COLLECT_DIR}/${TARNAME}.tgz"
                fi
            else
                report_error "failed to collect from ${host}" ${rc}
            fi

        # handle collect for this host as background task
        else
            # run collect_host in the background
           (collect_host_run "${host}" "${TARNAME}")&

            # save the child process's pid
            CHILD_PID=${!}

            #################################################################
            #
            # Add this collect_host';s background child process info
            # to the collect_host_ctrl_list
            #
            # collect_host_ctrl_list[index].hostname = host
            # collect_host_ctrl_list[index].stage    = RUN
            # collect_host_ctrl_list[index].pid      = invalid pid (-1)
            # collect_host_ctrl_list[index].seconds  = script time in secs
            # collect_host_ctrl_list[index].status   = default to FAIL
            # collect_host_ctrl_list[index].tarball  = host's tarball name
            #
            #################################################################
            collect_host_ctrl_list[${index}]="${host}:\
                                              ${STAGE_RUN}:\
                                              ${CHILD_PID}:\
                                              ${SECONDS}:\
                                              ${FAIL}:\
                                              ${TARNAME}"
            collect_host_ctrl_list_index_print ${index}
            index=$((index+1))
        fi
     fi
done

#############################################
#
# Parallel Collect in ASYNC=true mode
#
#############################################
monitoring=false
if [ "${ASYNC}" = true ] ; then
    # All hosts collected overall timeout
    while [ ${UNTIL} -ge ${SECONDS} ]
    do
        index=0
        monitoring=false
        for HOST in "${collect_host_ctrl_list[@]}"
        do
            info=(${HOST//:/ })
            # collect_host_ctrl_list_index_print ${index}
            if [ "${info[${INDEX_STAGE}]}" == "${STAGE_MON}" ] ; then

                # check to see if this collect_host pocess is done collecting
                kill -0 "${info[${INDEX_PID}]}" 2>/dev/null
                rc=${?}
                if [ ${rc} -ne 0 ] ; then

                    # the process is done ; get its exit code
                    wait "${info[${INDEX_PID}]}"
                    rc=${?}
                    if [ ${rc} == ${PASS} ] ; then

                        # if it passed then fetch that host's tarball
                        if [ "${info[${INDEX_HOST}]}" == "${HOSTNAME}" ] ; then
                            collect_host_complete_local  "${info[${INDEX_TARBALL}]}"
                        else
                            collect_host_complete_remote "${info[${INDEX_HOST}]}" \
                                                         "${info[${INDEX_TARBALL}]}"
                        fi

                        collect_host_done ${index} ${rc}
                        collect_host_stats ${index} ${rc}
                    else
                        collect_host_done ${index} ${rc}
                        report_error "failed to collect from ${info[${INDEX_HOST}]}" ${rc}
                    fi
                else
                    monitoring=true
                fi

            elif [ "${info[${INDEX_STAGE}]}" == "${STAGE_RUN}" ] ; then
                monitoring=true
                # update stage to Monitor
                collect_host_monitor ${index}
            fi
            index=$((index+1))
        done

        if [ "${monitoring}" = false ] ; then
            dlog "All hosts done ..."
            break
        fi
    done
    echo ""
fi

# Report that the overall collect timed-out
if [ "$monitoring" = true ]; then
    report_error "collect operation timeout after $TIMEOUT secs" ${FAIL_TIMEOUT}
fi

# Don't create a tarball if the collect name dir does not exists or contain files
if [ -d ${COLLECT_DIR} ] ; then
    stat ${COLLECT_DIR}/* 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ] ; then
        tarballs=(${COLLECT_DIR}/*)
        for tarball in ${tarballs[@]}
        do
            dlog "collected $tarball"
        done
    else
        elog "No ${COLLECT_DIR} tarballs found ; refusing to create empty ${TARBALL_NAME}"
        exit ${FAIL_NO_TARFILES}
    fi
else
    elog "${COLLECT_DIR} not present ; refusing to create empty ${TARBALL_NAME}"
    exit ${FAIL_NO_TARDIR}
fi

echo -n "creating ${named} tarball ${TARBALL_NAME} ... "

remove_file_local ${COLLECT_ERROR_LOG}
remove_file_local ${HOST_COLLECT_ERROR_LOG}

/usr/bin/expect << EOF
    log_user ${USER_LOG_MODE}
    spawn bash -i
    expect -re $
    set timeout 200
    send "(cd ${COLLECT_BASE_DIR} ; sudo ${IONICE_CMD} ${NICE_CMD} ${TAR_CMD} ${TARBALL_NAME} ${COLLECT_NAME}/* 2>>${COLLECT_ERROR_LOG} ; cat ${cmd_done_file})\n"
    expect {
        "assword:" {
            send "${pw}\r"
            expect {
                "${cmd_done_sig}" { exit ${PASS}            }
                "${pw_error}"     { exit ${FAIL_PASSWORD}   }
                "${ac_error}"     { exit ${FAIL_PERMISSION} }
                timeout           { exit ${FAIL_TIMEOUT1}   }
            }
        }
        timeout { exit ${FAIL_TIMEOUT} }
    }
EOF
   rc=${?}
   if [ ${rc} -ne ${PASS} ] ; then
       collect_errors ${HOSTNAME}
       report_error "failed to create ${TARBALL_NAME}" ${rc}
   else
       collect_errors ${HOSTNAME}
       rc=$?
       if [ ${rc} -eq ${PASS} ] ; then
           secs=$((SECONDS-COLLECT_START_TIME))
           echo -n "done"
           echo_stats $secs "stats-only" "${TARBALL_NAME}"
           logger -t ${COLLECT_TAG} "created ${named} tarball ${TARBALL_NAME}"
       else
           echo "removing incomplete collect: ${TARBALL_NAME}"
           remove_file_local "${TARBALL_NAME}"
       fi
   fi
   remove_file_local ${COLLECT_ERROR_LOG}
   remove_dir_local "${COLLECT_DIR}"

# return to callers dir
cd ${CURR_DIR}

exit ${rc}
